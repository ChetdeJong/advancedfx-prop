Version: April 02 update

Modules:
client 0d1c0000 - 0d31d000

Clues:

0:000> s -a client L1000000 "cl_crosshair_size"
0d2a7d28  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d2a7f03  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d412a24  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d412a48  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d412a60  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d412a8c  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d412ab4  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz

first match:
0:000> s client L1000000 28 7d 2a 0d
0d1ffa48  28 7d 2a 0d ff 15 98 4c-2e 0d 8b 46 10 b9 40 0a  (}*....L...F..@.
0d200ba7  28 7d 2a 0d 89 74 24 10-ff 15 a0 4c 2e 0d 8b e8  (}*..t$....L....

the first address belongs to a function that set's the default
cl_crosshair_size value.
the second address belongs to a function that handles the switching of the
crosshair based on cl_crosshair_size during hud drawing.
it seems to do some adjustments based on the resolution used.

second match:
is just a usage string that is spammed into the console by the function above

i.e. this is what the function does when cl_crosshair_size is auto:

0d200c59 a1084a2e0d      mov     eax,dword ptr [client!V_CalcRefdef+0xb8378 (0d2e4a08)]
0d200c5e 3d80020000      cmp     eax,offset <Unloaded_ud.drv>+0x27f (00000280)
0d200c63 7e18            jle     client!IN_ClearStates+0x1295d (0d200c7d)
0d200c65 3d00040000      cmp     eax,offset <Unloaded_ud.drv>+0x3ff (00000400)
0d200c6a 7c22            jl      client!IN_ClearStates+0x1296e (0d200c8e)
0d200c6c c7466c80020000  mov     dword ptr [esi+6Ch],offset <Unloaded_ud.drv>+0x27f (00000280)
0d200c73 5e              pop     esi
0d200c74 5d              pop     ebp
0d200c75 5b              pop     ebx
0d200c76 59              pop     ecx
0d200c77 c3              ret

This is where the function is called:

0d201a4a 8bcf            mov     ecx,edi
0d201a4c e84ff1ffff      call    client!IN_ClearStates+0x12880 (0d200ba0)
0d201a51 8b4f6c          mov     ecx,dword ptr [edi+6Ch]

anways, this function is called by a more ecomplex unknown function that is called as follows:

0d201132 50              push    eax
0d201133 56              push    esi
0d201134 8bcd            mov     ecx,ebp
0d201136 e865060000      call    client!IN_ClearStates+0x13480 (0d2017a0)
0d20113b 391d48022c0d    cmp     dword ptr [client!V_CalcRefdef+0x93bb8 (0d2c0248)],ebx

this is actually a class function (probably client hud class or s.th.)
which gets passed two parameters, one seems to be the time, the other the weaponcode (id):

0d2017a0 83ec08          sub     esp,8
0d2017a3 8b442410        mov     eax,dword ptr [esp+10h]
0d2017a7 53              push    ebx
0d2017a8 55              push    ebp
0d2017a9 56              push    esi
0d2017aa 57              push    edi
0d2017ab 8bf9            mov     edi,ecx
0d2017ad 8d48ff          lea     ecx,[eax-1]
0d2017b0 897c2414        mov     dword ptr [esp+14h],edi
0d2017b4 83f91d          cmp     ecx,1Dh
0d2017b7 ba04000000      mov     edx,offset <Unloaded_ud.drv>+0x3 (00000004)
0d2017bc be05000000      mov     esi,offset <Unloaded_ud.drv>+0x4 (00000005)
0d2017c1 0f8791000000    ja      client!IN_ClearStates+0x13538 (0d201858)

// here it would do some adjustments accordings to the weapon
...

// this checks cl_dynamic crosshair:

0d201877 a184032e0d      mov     eax,dword ptr [client!V_CalcRefdef+0xb3cf4 (0d2e0384)]
0d20187c 85c0            test    eax,eax
0d20187e 0f84c8000000    je      client!IN_ClearStates+0x1362c (0d20194c)
0d201884 d9400c          fld     dword ptr [eax+0Ch]
0d201887 d81d2432280d    fcomp   dword ptr [client!V_CalcRefdef+0x56b94 (0d283224)]
0d20188d dfe0            fnstsw  ax
...

// i.e. here it checks some walking stuff:
0d20194c 8b0d44032e0d    mov     ecx,dword ptr [client!V_CalcRefdef+0xb3cb4 (0d2e0344)]
0d201952 8b4740          mov     eax,dword ptr [edi+40h]
0d201955 3bc8            cmp     ecx,eax
...

// here it loads from the class pointer (edi) the old drawing position (so it always draws a delta somewhat)
0d201992 d94744          fld     dword ptr [edi+44h]
0d201995 dd05c8d4280d    fld     qword ptr [client!V_CalcRefdef+0x60e38 (0d28d4c8)]
0d20199b d8c9            fmul    st,st(1)
0d20199d 83c002          add     eax,2
0d2019a0 894748          mov     dword ptr [edi+48h],eax
0d2019a3 dc05c832280d    fadd    qword ptr [client!V_CalcRefdef+0x56c38 (0d2832c8)]

// as you can see two constants get used here, one for multiplication (fmul) and one for addition (fadd)

// this is what we need to patch upon fps change

// and here is where the drawing function is called:

...
0d201bf8 a1084a2e0d      mov     eax,dword ptr [client!V_CalcRefdef+0xb8378 (0d2e4a08)]
0d201bfd 99              cdq
0d201bfe 2bc2            sub     eax,edx
0d201c00 d1f8            sar     eax,1
0d201c02 50              push    eax
0d201c03 ff158c4c2e0d    call    dword ptr [client!V_CalcRefdef+0xb85fc (0d2e4c8c)]
0d201c09 83c440          add     esp,40h
0d201c0c b801000000      mov     eax,offset <Unloaded_ud.drv> (00000001)
0d201c11 5f              pop     edi
0d201c12 5e              pop     esi
0d201c13 5d              pop     ebp
0d201c14 5b              pop     ebx
0d201c15 83c408          add     esp,8
0d201c18 c20800          ret     8

So what you need to do is detour the class function
(0d1f1b20) and access the two parameters (fmul) and
(fadd), see above.
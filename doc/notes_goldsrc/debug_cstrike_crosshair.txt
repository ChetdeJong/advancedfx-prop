Version: March 06 update

Modules:
client 0d1b0000 - 0d30d000

Clues:

0:000> s -a client L1000000 "cl_crosshair_size"
0d297d28  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d297f03  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d402a0c  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d402a30  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d402a48  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d402a74  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz
0d402a9c  63 6c 5f 63 72 6f 73 73-68 61 69 72 5f 73 69 7a  cl_crosshair_siz

frist match:
0:000> s client L1000000 28 7d 29 0d
0d1efdc8  28 7d 29 0d ff 15 a0 4b-2d 0d 8b 46 10 b9 40 0a  (})....K-..F..@.
0d1f0f27  28 7d 29 0d 89 74 24 10-ff 15 a8 4b 2d 0d 8b e8  (})..t$....K-...

the first address belongs to a function that set's the default
cl_crosshair_size value.
the second address belongs to a function that handles the switching of the
crosshair based on cl_crosshair_size during hud drawing.
it seems to do some adjustments based on the resolution used.

second match:
is just a usage string that is spammed into the console by the function above

i.e. this is what the function does when cl_crosshair_size is auto:

0d1f0fd9 a110492d0d      mov     eax,dword ptr [client!V_CalcRefdef+0xb7f00 (0d2d4910)]
0d1f0fde 3d80020000      cmp     eax,offset <Unloaded_ud.drv>+0x27f (00000280)
0d1f0fe3 7e18            jle     client!IN_ClearStates+0x1295d (0d1f0ffd)
0d1f0fe5 3d00040000      cmp     eax,offset <Unloaded_ud.drv>+0x3ff (00000400)
0d1f0fea 7c22            jl      client!IN_ClearStates+0x1296e (0d1f100e)
0d1f0fec c7466c80020000  mov     dword ptr [esi+6Ch],offset <Unloaded_ud.drv>+0x27f (00000280)
0d1f0ff3 5e              pop     esi
0d1f0ff4 5d              pop     ebp
0d1f1017 5b              pop     ebx
0d1f1018 59              pop     ecx
0d1f1019 c3              ret

This is where the function is called:

0d1f1dca 8bcf            mov     ecx,edi
0d1f1dcc e84ff1ffff      call    client!IN_ClearStates+0x12880 (0d1f0f20)
0d1f1dd1 8b4f6c          mov     ecx,dword ptr [edi+6Ch]

anways, this function is called by a more ecomplex unknown function that is called as follows:

0d1f14b2 50              push    eax
0d1f14b3 56              push    esi
0d1f14b4 8bcd            mov     ecx,ebp
0d1f14b6 e865060000      call    client!IN_ClearStates+0x13480 (0d1f1b20)
0d1f14bb 391d50012b0d    cmp     dword ptr [client!V_CalcRefdef+0x93740 (0d2b0150)],ebx

this is actually a class function (probably client hud class or s.th.)
which gets passed two parameters, one seems to be the time, the other the weaponcode (id):

0d1f1b20 83ec08          sub     esp,8
0d1f1b23 8b442410        mov     eax,dword ptr [esp+10h]
0d1f1b27 53              push    ebx
0d1f1b28 55              push    ebp
0d1f1b29 56              push    esi
0d1f1b2a 57              push    edi
0d1f1b2b 8bf9            mov     edi,ecx
0d1f1b2d 8d48ff          lea     ecx,[eax-1]
0d1f1b30 897c2414        mov     dword ptr [esp+14h],edi
0d1f1b34 83f91d          cmp     ecx,1Dh
0d1f1b37 ba04000000      mov     edx,offset <Unloaded_ud.drv>+0x3 (00000004)
0d1f1b3c be05000000      mov     esi,offset <Unloaded_ud.drv>+0x4 (00000005)
0d1f1b41 0f8791000000    ja      client!IN_ClearStates+0x13538 (0d1f1bd8)

// here it would do some adjustments accordings to the weapon
...

// this checks cl_dynamic crosshair:

0d1f1bf7 a18c022d0d      mov     eax,dword ptr [client!V_CalcRefdef+0xb387c (0d2d028c)]
0d1f1bfc 85c0            test    eax,eax
0d1f1bfe 0f84c8000000    je      client!IN_ClearStates+0x1362c (0d1f1ccc)
0d1f1c04 d9400c          fld     dword ptr [eax+0Ch]
0d1f1c07 d81d2432270d    fcomp   dword ptr [client!V_CalcRefdef+0x56814 (0d273224)]
0d1f1c0d dfe0            fnstsw  ax
...

// i.e. here it checks some walking stuff:
0d1f1ccc 8b0d4c022d0d    mov     ecx,dword ptr [client!V_CalcRefdef+0xb383c (0d2d024c)]
0d1f1cd2 8b4740          mov     eax,dword ptr [edi+40h]
0d1f1cd5 3bc8            cmp     ecx,eax

// here it loads from the class pointer (edi) the old drawing position (so it always draws a delta somewhat)
0d1f1d12 d94744          fld     dword ptr [edi+44h]
0d1f1d15 dd0530d5270d    fld     qword ptr [client!V_CalcRefdef+0x60b20 (0d27d530)]
0d1f1d1b d8c9            fmul    st,st(1)
0d1f1d1d 83c002          add     eax,2
0d1f1d20 894748          mov     dword ptr [edi+48h],eax
0d1f1d23 dc05c832270d    fadd    qword ptr [client!V_CalcRefdef+0x568b8 (0d2732c8)]

// as you can see two constants get used here, one for multiplication (fmul) and one for addition (fadd)

// this is what we need to patch upon fps change

// and here is where the drawing function is called:

...
0d1f1f78 a110492d0d      mov     eax,dword ptr [client!V_CalcRefdef+0xb7f00 (0d2d4910)]
0d1f1f7d 99              cdq
0d1f1f7e 2bc2            sub     eax,edx
0d1f1f80 d1f8            sar     eax,1
0d1f1f82 50              push    eax
0d1f1f83 ff15944b2d0d    call    dword ptr [client!V_CalcRefdef+0xb8184 (0d2d4b94)]
0d1f1f89 83c440          add     esp,40h
0d1f1f8c b801000000      mov     eax,offset <Unloaded_ud.drv> (00000001)
0d1f1f91 5f              pop     edi
0d1f1f92 5e              pop     esi
0d1f1f93 5d              pop     ebp
0d1f1f94 5b              pop     ebx
0d1f1f95 83c408          add     esp,8
0d1f1f98 c20800          ret     8

So what you need to do is detour the class function
(0d1f1b20) and access the two parameters (fmul) and
(fadd), see above.
Version: March 06 update

See Half-Life SDK:
C:\Libraries\hlsdk\multiplayer\cl_dll\death.cpp

Modules
client 0d1b0000 - 0d30d000

0:000> s -a client L1000000 "DeathMsg"
0d29870c  44 65 61 74 68 4d 73 67-00 00 00 00 64 5f 73 6b  DeathMsg....d_sk

0:000> s client L1000000 0c 87 29 0d
0d1f49b4  0c 87 29 0d ff 15 b0 4b-2d 0d 6a 00 68 08 87 29  ..)....K-.j.h..)

0d1f49ae 6830491f0d      push    offset client!F+0x920 (0d1f4930)
0d1f49b3 680c87290d      push    offset client!V_CalcRefdef+0x7bcfc (0d29870c)
0d1f49b8 ff15b04b2d0d    call    dword ptr [client!V_CalcRefdef+0xb81a0 (0d2d4bb0)]

==>
0d1f49ae => 0d1f4930 is the DeatMsg func (see DECLARE_MESSAGE macro in HLSDK):

DECLARE_MESSAGE( m_DeathNotice, DeathMsg );

// int __MsgFunc_DeathMsg(const char *pszName, int iSize, void *pbuf)
// {
// 	return gHUD.m_DeathNotice.MsgFunc_DeathMsg(pszName, iSize, pbuf );
// }
//
0d1f4930 8b44240c        mov     eax,dword ptr [esp+0Ch]
0d1f4934 8b4c2408        mov     ecx,dword ptr [esp+8]
0d1f4938 8b542404        mov     edx,dword ptr [esp+4]
0d1f493c 50              push    eax
0d1f493d 51              push    ecx
0d1f493e 52              push    edx
0d1f493f b9e0412d0d      mov     ecx,offset client!V_CalcRefdef+0xb77d0 (0d2d41e0)
0d1f4944 e8c7040000      call    client!F+0xe00 (0d1f4e10)
0d1f4949 c3              ret

==>
0d1f4944 => 0d1f4e10 is CHudDeathNotice :: MsgFunc_DeathMsg

0d1f4e10
...

// >>

//	for ( int i = 0; i < MAX_DEATHNOTICES; i++ )
//	{
//		if ( rgDeathNoticeList[i].iId == 0 )
//			break;
//	}
// asm code looks a bit different, probably due to optimization:
0d1f4e94 33f6            xor     esi,esi
0d1f4e96 b8484e2d0d      mov     eax,offset client!V_CalcRefdef+0xb8438 (0d2d4e48)
0d1f4e9b 833800          cmp     dword ptr [eax],0
0d1f4e9e 740d            je      client!F+0xe9d (0d1f4ead)
0d1f4ea0 05a0000000      add     eax,0A0h
0d1f4ea5 46              inc     esi
0d1f4ea6 3dc8502d0d      cmp     eax,offset client!V_CalcRefdef+0xb86b8 (0d2d50c8)
0d1f4eab 7cee            jl      client!F+0xe8b (0d1f4e9b)

--> 0d2d4e48 -0x80 == rgDeathNoticeList

//	if ( i == MAX_DEATHNOTICES )
//	{ // move the rest of the list forward to make room for this item
//		memmove( rgDeathNoticeList, rgDeathNoticeList+1, sizeof(DeathNoticeItem) * MAX_DEATHNOTICES );
//		i = MAX_DEATHNOTICES - 1;
//	}
0d1f4ead 83fe04          cmp     esi,4
0d1f4eb0 751c            jne     client!F+0xebe (0d1f4ece)
0d1f4eb2 6880020000      push    280h
0d1f4eb7 68684e2d0d      push    offset client!V_CalcRefdef+0xb8458 (0d2d4e68)
0d1f4ebc 68c84d2d0d      push    offset client!V_CalcRefdef+0xb83b8 (0d2d4dc8)
0d1f4ec1 e8ba5c0600      call    client!V_CalcRefdef+0x3e170 (0d25ab80)
0d1f4ec6 83c40c          add     esp,0Ch
0d1f4ec9 be03000000      mov     esi,3

// << 

--> 0d2d4dc8 is rgDeathNoticeList

next thing to patch is the drawing function, so we search for acces rgDeathNoticeList.iId:

0:000> s client L1000000 48 4e 2d 0d
0d1f4b02  48 4e 2d 0d 85 c0 0f 84-f0 02 00 00 d9 87 5c 4e  HN-...........\N
0d1f4bb0  48 4e 2d 0d 03 ea 83 f8-ff 75 09 8b 4e 14 89 4c  HN-......u..N..L
0d1f4e97  48 4e 2d 0d 83 38 00 74-0d 05 a0 00 00 00 46 3d  HN-..8.t......F=
0d1f5056  48 4e 2d 0d 85 ff 74 17-68 d0 87 29 0d b9 d8 03  HN-...t.h..)....

==>
0d1f4b02 -2 == 0d1f4b00 is inside CHudDeathNotice :: Draw

0d1f4a90 is CHudDeathNotice :: Draw 
...
// 		if ( rgDeathNoticeList[i].iId == 0 )
// 			break;  // we've gone through them all
0d1f4b00 8b87484e2d0d    mov     eax,dword ptr client!V_CalcRefdef+0xb8438 (0d2d4e48)[edi]
0d1f4b06 85c0            test    eax,eax
0d1f4b08 0f84f0020000    je      client!F+0xdee (0d1f4dfe)

// 		if ( rgDeathNoticeList[i].flDisplayTime < flTime )
// 		{ // display time has expired
// 			// remove the current item from the list
// 			memmove( &rgDeathNoticeList[i], &rgDeathNoticeList[i+1], sizeof(DeathNoticeItem) * (MAX_DEATHNOTICES - i) );
// 			i--;  // continue on the next item;  stop the counter getting incremented
// 			continue;
// 		}
0d1f4b0e d9875c4e2d0d    fld     dword ptr client!V_CalcRefdef+0xb844c (0d2d4e5c)[edi]
0d1f4b14 d85c2450        fcomp   dword ptr [esp+50h]
0d1f4b18 dfe0            fnstsw  ax
0d1f4b1a f6c405          test    ah,5
0d1f4b1d 7a41            jp      client!F+0xb50 (0d1f4b60)
0d1f4b1f 8b6c2420        mov     ebp,dword ptr [esp+20h]
0d1f4b23 8b542414        mov     edx,dword ptr [esp+14h]
0d1f4b27 b980020000      mov     ecx,offset <Unloaded_ud.drv>+0x27f (00000280)
0d1f4b2c 2bcf            sub     ecx,edi
0d1f4b2e 51              push    ecx
0d1f4b2f 55              push    ebp
0d1f4b31 e84a600600      call    client!V_CalcRefdef+0x3e170 (0d25ab80)
0d1f4b36 8b542420        mov     edx,dword ptr [esp+20h]
0d1f4b3a 8b4c2428        mov     ecx,dword ptr [esp+28h]
0d1f4b3e b8a0000000      mov     eax,offset <Unloaded_ud.drv>+0x9f (000000a0)
0d1f4b43 83c40c          add     esp,0Ch
0d1f4b46 4b              dec     ebx
0d1f4b47 2bf8            sub     edi,eax
0d1f4b49 2be8            sub     ebp,eax
0d1f4b4b 2bd0            sub     edx,eax
0d1f4b4d 2bc8            sub     ecx,eax
0d1f4b4f 896c2420        mov     dword ptr [esp+20h],ebp
0d1f4b53 89542414        mov     dword ptr [esp+14h],edx
0d1f4b57 894c241c        mov     dword ptr [esp+1Ch],ecx
0d1f4b5b e96c020000      jmp     client!F+0xdbc (0d1f4dcc)

// 		rgDeathNoticeList[i].flDisplayTime = min( rgDeathNoticeList[i].flDisplayTime, gHUD.m_flTime + DEATHNOTICE_DISPLAY_TIME );
0d1f4b60 db05b086290d    fild    dword ptr [client!V_CalcRefdef+0x7bca0 (0d2986b0)]
0d1f4b66 d805fc032d0d    fadd    dword ptr [client!V_CalcRefdef+0xb39ec (0d2d03fc)]
0d1f4b6c d9875c4e2d0d    fld     dword ptr client!V_CalcRefdef+0xb844c (0d2d4e5c)[edi]
0d1f4b72 d8d9            fcomp   st(1)
0d1f4b74 dfe0            fnstsw  ax
0d1f4b76 f6c405          test    ah,5
0d1f4b79 7a08            jp      client!F+0xb73 (0d1f4b83)
0d1f4b7b ddd8            fstp    st(0)
0d1f4b7d d9875c4e2d0d    fld     dword ptr client!V_CalcRefdef+0xb844c (0d2d4e5c)[edi]
0d1f4b83 8b0df0382f0d    mov     ecx,dword ptr [client!V_CalcRefdef+0xd6ee0 (0d2f38f0)]
0d1f4b89 d99f5c4e2d0d    fstp    dword ptr client!V_CalcRefdef+0xb844c (0d2d4e5c)[edi]

// 		if ( gViewPort && gViewPort->AllowedToPrintText() )
0d1f4b8f 85c9            test    ecx,ecx
0d1f4b91 0f8430020000    je      client!F+0xdb7 (0d1f4dc7)
0d1f4b97 8b01            mov     eax,dword ptr [ecx]
0d1f4b99 ff500c          call    dword ptr [eax+0Ch]
0d1f4b9c 84c0            test    al,al
0d1f4b9e 0f8423020000    je      client!F+0xdb7 (0d1f4dc7)

// 	y = YRES(DEATHNOTICE_TOP) + 2 + (20 * i);  //!!!
0d1f4ba4 8b6e18          mov     ebp,dword ptr [esi+18h]
0d1f4ba7 8b542438        mov     edx,dword ptr [esp+38h]
0d1f4bab 0fafeb          imul    ebp,ebx

// 	int id = (rgDeathNoticeList[i].iId == -1) ? m_HUD_d_skull : rgDeathNoticeList[i].iId;
0d1f4bae 8b87484e2d0d    mov     eax,dword ptr client!V_CalcRefdef+0xb8438 (0d2d4e48)[edi]
0d1f4bb4 03ea            add     ebp,edx
0d1f4bb6 83f8ff          cmp     eax,0FFFFFFFFh
...

Note:
In the code we also patch the YRES drawing part (cstrike_DeathMsg_DrawHelperY),
this might need to be adjusted too upon updates.
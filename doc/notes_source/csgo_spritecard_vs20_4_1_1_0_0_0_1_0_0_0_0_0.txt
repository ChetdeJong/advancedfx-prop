// ORIENTATION = 4
// ZOOM_ANIMATE_SEQ2 = 1
// DUALSEQUENCE = 1
// ADDBASETEXTURE2 = 0
// EXTRACTGREENALPHA = 0
// DEPTHBLEND = 0
// ANIMBLEND_OR_MAXLUMFRAMEBLEND1 = 1
// CROP = 0
// PACKED_INTERPOLATOR = 0
// SPRITECARDVERTEXFOG = 0
// HARDWAREFOGBLEND = 0
// PERPARTICLEOUTLINE = 0 

//
// Generated by Microsoft (R) D3DX9 Shader Compiler 5.04.00.3900
//
// Parameters:
//
//   float4 ScaleParms;
//   float4 SizeParms;
//   float4 SizeParms2;
//   float4 cEyePos_WaterHeightW;
//   float4x3 cModel[53];
//   float4x4 cViewProj;
//
//
// Registers:
//
//   Name                 Reg   Size
//   -------------------- ----- ----
//   cEyePos_WaterHeightW c2       1
//   cViewProj            c8       4
//   ScaleParms           c55      1
//   SizeParms            c56      1
//   SizeParms2           c57      1
//   cModel               c58      3
//

    vs_2_0
          def c1, 6.28318548 = 2*PI, -3.14159274 = -PI, 2, -1
          def c3, 2.20000005, 0.159154937 = 1 / (2*PI), 0.5, 0.00392156886
          def c4, -2, 3, -0.5, 0
          def c5, -1.55009923e-006, -2.17013894e-005, 0.00260416674, 0.00026041668 // = D3DSINCOSCONST1
          def c6, -0.020833334, -0.125, 1, 0.5 // = D3DSINCOSCONST2
          dcl_color v0
          dcl_position v1
          dcl_texcoord v2
          dcl_texcoord1 v3
          dcl_texcoord2 v4
          dcl_texcoord3 v5
          dcl_texcoord5 v6
          dcl_texcoord6 v7
          dcl_texcoord7 v8

	float3 worldPos;
	r4.xyz = worldPos = mul4x3( v.vPos, cModel[0] );
	
   0:     dp4 r4.x, v1, c58
   1:     dp4 r4.y, v1, c59
   2:     dp4 r4.z, v1, c60

	float3 v2p = ( worldPos - cEyePos );
	r5.xyz=(v2p.y,v2p.z,v2p.x,v2p.w);
	float4 tint = GammaToLinear( v.vTint ) = r0;
	float l = length(v2p);
	r0.w = 1/l
	r6.w = l;
	r3 = tint;
	
   3:     add r5.xyz, r4.yzxw, -c2.yzxw
   4:     log r0.x, v0.x
   5:     log r0.y, v0.y
   6:     log r0.z, v0.z
   7:     dp3 r1.x, r5, r5
   8:     mul r0.xyz, r0, c3.x
   9:     rsq r0.w, r1.x
  10:     exp r3.x, r0.x
  11:     exp r3.y, r0.y
  12:     exp r3.z, r0.z
  13:     rcp r6.w, r0.w
  14:     mov r3.w, v0.w

	r0 = float4(MINIMUM_SIZE_FACTOR*l, START_FADE_SIZE_FACTOR*l, END_FADE_SIZE_FACTOR*l, MAXIMUM_SIZE_FACTOR*l);
	r1.w = END_FADE_SIZE_FACTOR*l - START_FADE_SIZE_FACTOR*l;
	r4.w = max(MINIMUM_SIZE_FACTOR*l, RADIUS)
	r2.w = 1/(END_FADE_SIZE_FACTOR*l - START_FADE_SIZE_FACTOR*l);
	
	float rad = RADIUS;
	rad=max(rad, MINIMUM_SIZE_FACTOR * l);
	r4.w = rad;
	
  15:     mul r0, r6.w, c56.xzwy
  16:     mad r1.w, c56.w, r6.w, -r0.y
  17:     max r4.w, r0.x, v4.z
  18:     rcp r2.w, r1.w

BEGIN [1]
	r1.w = START_FADE_SIZE_FACTOR * -l +rad
  19:     mad r1.w, c56.z, -r6.w, r4.w
  20:     mad r1.w, r1.w, -r2.w, c0.y

	r2.w = l -START_FAR_FADE
  21:     add r2.w, r6.w, -c57.x

	r1 = tint * (START_FADE_SIZE_FACTOR * -l +rad)
  22:     mul r1, r3, r1.w
  
	r2.w = (l -START_FAR_FADE) *FAR_FADE_FACTOR
  23:     mul r2.w, r2.w, c57.y
  
	r0.xy = (START_FADE_SIZE_FACTOR*l < rad ? 1.0 : 0.0,  END_FADE_SIZE_FACTOR*l < rad ? 1.0 : 0.0);
  24:     slt r0.xy, r0.yzzw, r4.w
  
	r5.w = max((l -START_FAR_FADE) *FAR_FADE_FACTOR,0.0);
  25:     max r5.w, r2.w, c0.x
  
	r2 = END_FADE_SIZE_FACTOR*l < rad ? float4(0.0,0.0,0.0,0.0) : tint * (START_FADE_SIZE_FACTOR * -l +rad)
  26:     mad r2, r0.y, -r1, r1
  
	r5.w = min(1.0,max((l -START_FAR_FADE) *FAR_FADE_FACTOR,0.0))
  27:     min r5.w, r5.w, c0.y
  
	r1 = lerp(END_FADE_SIZE_FACTOR*l < rad ? float4(0.0,0.0,0.0,0.0) : tint * (START_FADE_SIZE_FACTOR * -l +rad),tint,START_FADE_SIZE_FACTOR*l < rad ? 1.0 : 0.0)
  28:     lrp r1, r0.x, r2, r3
  
	r3.w = 1.0 -min(1.0,(l -START_FAR_FADE) *FAR_FADE_FACTOR,0.0);
	float tscale = 1-min(1, max(0, (l-START_FAR_FADE)*FAR_FADE_FACTOR) );
	r3.w = tscale;
  29:     add r3.w, -r5.w, c0.y  
  
	r1 = r1 * r3.w
	tint *= tscale;
	r1 = tint;
  30:     mul r1, r1, r3.w
  
	r2.w = -rad * (END_FADE_SIZE_FACTOR*l < rad ? 1.0 : 0.0)
  31:     mul r2.w, -r4.w, r0.y

	r3.w = 0.0 >= tscale ? 1.0 : 0.0;
  32:     sge r3.w, c0.x, r3.w
  
	r4.w = (START_FADE_SIZE_FACTOR*l < rad ? 1.0 : 0.0) * -rad * (END_FADE_SIZE_FACTOR*l < rad ? 1.0 : 0.0) +rad
	r4.w = (START_FADE_SIZE_FACTOR*l < rad  && END_FADE_SIZE_FACTOR*l < rad) ? 0.0 : rad;
  33:     mad r4.w, r0.x, r2.w, r4.w

	r2.w = tint.a < ONE_OVER_255 ? 1.0 : 0.0
  34:     slt r2.w, r1.w, c3.w
  
	r3.w = 0.0 >= tscale ? 0.0 : ((START_FADE_SIZE_FACTOR*l < rad  && END_FADE_SIZE_FACTOR*l < rad) ? 0.0 : rad)
  35:     mad r3.w, r3.w, -r4.w, r4.w
  
	r2.w =  tint.a < ONE_OVER_255 ? 0.0 : (0.0 >= tscale ? 0.0 : ((START_FADE_SIZE_FACTOR*l < rad  && END_FADE_SIZE_FACTOR*l < rad) ? 0.0 : rad))
  36:     mad r2.w, r2.w, -r3.w, r3.w
END [1]
  
Code block [1] sums up to:
	// now, perform fade out
	if ( rad > START_FADE_SIZE_FACTOR * l )
	{
		if ( rad > END_FADE_SIZE_FACTOR *l )
		{
			tint = 0;
			rad = 0;											// cull so we emit 0-sized sprite
		}
		else
		{
			tint *= 1-(rad-START_FADE_SIZE_FACTOR*l)/(END_FADE_SIZE_FACTOR*l-START_FADE_SIZE_FACTOR*l);
		}
	}

	// perform far fade
	float tscale =  1-min(1, max(0, (l-START_FAR_FADE)*FAR_FADE_FACTOR) );
	tint *= tscale;

	if ( tscale <= 0 )
		rad = 0;											// cull so we emit 0-sized sprite

	if ( tint.a < ONE_OVER_255 )
	{
		// save fillrate by transforming completely transparent particles to a point
		rad = 0;
	}
	
Where
	r1 = tint
	r2.w = rad;
.

	rad = min( rad, MAXIMUM_SIZE_FACTOR * l );
	r5.w = rad;
  37:     min r5.w, r0.w, r2.w
  
//// //// //// //// //// //// //// ////

BEGIN [2]
  
	r3.w = rad * 0.5;
  38:     mul r3.w, r5.w, c0.w
  
	r0.w = -0.5 * rad  +l
  39:     mad r0.w, r5.w, -c0.w, r6.w
  
	r2.w = 1/(rad * 0.5)
  40:     rcp r2.w, r3.w
  
	r0.w = (-0.5 * rad  +l) / (rad * 0.5)
  41:     mul r0.w, r0.w, r2.w
  
	r0.w = max((-0.5 * rad  +l) / (rad * 0.5),0.0)
  42:     max r0.w, r0.w, c0.x
  
	r2.w = min(max((-0.5 * rad  +l) / (rad * 0.5),0.0),1.0)
  43:     min r2.w, r0.w, c0.y
  
	r0.w = min(max((-0.5 * rad  +l) / (rad * 0.5),0.0),1.0) * -2 +3
  44:     mad r0.w, r2.w, c4.x, c4.y
  
	r2.w = [min(max((-0.5 * rad  +l) / (rad * 0.5),0.0),1.0)]^2
  45:     mul r2.w, r2.w, r2.w
  
	r4.w = rad * 0.5 < l ? 1.0 : 0.0
  46:     slt r4.w, r3.w, r6.w
  
	r0.w = (min(max((-0.5 * rad  +l) / (rad * 0.5),0.0),1.0) * -2 +3) * [min(max((-0.5 * rad  +l) / (rad * 0.5),0.0),1.0)]^2
	r0.w = smoothstep(0.5 * rad, rad, l);
  47:     mul r0.w, r0.w, r2.w

	r0 = tint * ( smoothstep(0.5 * rad, rad, l) -1)
  48:     mad r0, r1, r0.w, -r1
  
	r2.xy = (YAW/(2*PI) +0.5,ROTATION/(2*PI) +0.5)
  49:     mad r2.xy, v4.wyzw, c3.y, c3.z
  
	r2.w = 2 * rad;
  50:     add r2.w, r5.w, r5.w
  
	r2.xy = frac(r2.xy)
  51:     frc r2.xy, r2
  
	r2.w = l < 2 * rad ? 1.0 : 0.0;
  52:     slt r2.w, r6.w, r2.w
  
	r6.xy = frac(r2.xy)* 2 * PI -PI
  53:     mad r6.xy, r2, c1.x, c1.y
  
	r0 *= r2.w
	r0 = l < 2 * rad ? [tint * (smoothstep(0.5 * rad, rad, l) -1)] : 0.0;
  54:     mul r0, r0, r2.w
  
	float2 sc;
	sincos( ROTATION, sc.y, sc.x );
	r3.x = sc.x;
	r3.y = sc.y;
	r3.z = undefined
  55:     sincos r3.xy, r6.y, c5, c6

	float2 sc_yaw;
	sincos( YAW, sc_yaw.y, sc_yaw.x );
	r2.x = sc_yaw.x;
	r2.y = sc_yaw.y;
	r2.z = undefined
  63:     sincos r2.xy, r6.x, c5, c6
  
	r6.xyz = float3(0,v2p.z,0);
  71:     mul r6.xyz, r5.zxyw, c0.xyxw
  
	float2 ix = 2 * v.vCornerID.xy - 1;
	r8.xy = ix;
  72:     mad r8.xy, c1.z, v5, c1.w
  
  r6.xyz = float3(0,-v2p.y,v2p.x)
  73:     mad r6.xyz, r5, c0.xxyw, -r6
  
  r7.xyw = float3(sc.x,sc.y,sc.y) * float3(ix.x,ix.y,ix.x);
  74:     mul r7.xyw, r3.xyzy, r8.xyzx
  
  r2.w = ix.y * sc.x -sc.y * ix.x
  float y1 = sc.x * ix.y - sc.y * ix.x;
  r2.w = y1
  75:     mad r2.w, r8.y, r3.x, -r7.w

	r3.w = sc.y*ix.y +sc.x*ix.x;
	float x1 = dot( ix, sc );
	r3.w = x1;
  76:     add r3.w, r7.y, r7.x
  
	r3 = normalize(r6);
 		float3 up = float3(0,0,1);
		float3 right = normalize(cross(up, v2p));
	r3.xyz = right.zxy;
  77:     nrm r3.xyz, r6
  
	r3.w = rad * x1;
  80:     mul r3.w, r5.w, r3.w
  
	r6.xyw = float3(sc_yaw.x,sc_yaw.y,sc_yaw.y) * float3(right.x,right.y,right.x);
  81:     mul r6.xyw, r2.xyzy, r3.yzzy

	r2.w = rad * y1
  82:     mul r2.w, r5.w, r2.w
  
	r2.y = right.y * sc_yaw.x -sc_yaw.y * right.x
  83:     mad r2.y, r3.z, r2.x, -r6.w
  
	r2.x = sc_yaw.y * right.y +sc_yaw.x * right.x
  84:     add r2.x, r6.y, r6.x
  
	r6.xyz = float3(v2p.y*right.z,v2p.z*right.x,v2p.x*right.y);
  85:     mul r6.xyz, r5, r3
  
	r2.z = right.z;
  86:     mov r2.z, r3.x

	r5.xyz = float3(right.y,right.z,right.x) * float3(v2p.z,v2p.x,v2p.y) -float3(v2p.y*right.z,v2p.z*right.x,v2p.x*right.y);
	r5.xyz = cross(right,v2p);
  87:     mad r5.xyz, r3.zxyw, r5.yzxw, -r6
  
	r3.xyz = rad * x1 * float3(sc_yaw.y * right.y +sc_yaw.x * right.x, right.y * sc_yaw.x -sc_yaw.y * right.x, right.z) +worldPos
  88:     mad r3.xyz, r3.w, r2, r4
  
	r2.xyz = normalize(cross(right,v2p));
  89:     nrm r2.xyz, r5
  
	oD0 = (rad * 0.5 < l ? 1.0 : 0.0) * [l < 2 * rad ? [tint * (smoothstep(0.5 * rad, rad, l) -1)] : 0.0] +tint
	oD0 = rad * 0.5 < l && l < 2 * rad ? tint * smoothstep(0.5 * rad, rad, l) : tint;
  92:     mad oD0, r4.w, r0, r1
  
	r1.xyz = rad * y1 * normalize(cross(right,v2p)) +rad * x1 * float3(sc_yaw.y * right.y +sc_yaw.x * right.x, right.y * sc_yaw.x -sc_yaw.y * right.x, right.z) +worldPos;
  93:     mad r1.xyz, r2.w, r2, r3
  
	r0.xyz = worldPos
		+(rad * 0.5 < l
			? rad * y1 * normalize(cross(right,v2p)) +rad * x1 * float3(sc_yaw.y * right.y +sc_yaw.x * right.x, right.y * sc_yaw.x -sc_yaw.y * right.x, right.z)
			: 0.0
		);
	)
  94:     lrp r0.xyz, r4.w, r1, r4
END [2]
  
Code block [2] sums up to:

	// Z-aligned case
	if (l > rad/2)
	{
		float3 up = float3(0,0,1);
		float3 right = normalize(cross(up, v2p));
		
		up = normalize(cross(right,v2p)); // THIS SEEMS TO BE THE ONLY REALLY NEW THING for ORIENTATION==4
		
		float tmpx = right.x * sc_yaw.x + right.y * sc_yaw.y;
		right.y = right.y * sc_yaw.x - right.x * sc_yaw.y;
		right.x = tmpx;

		worldPos += ( x1 * rad ) * right;
		worldPos += ( y1 * rad ) * up;
		
		if (l < rad*2 )
		{
			tint *= smoothstep(rad/2,rad,l);
		}
Where
	r0.xyz = worldPos;
	oD0 = tint;
.

  
	r0 = float4(worldPos, 1.0f);
	oPos = projPos  = mul( float4(worldPos, 1.0f), cViewProj );
	r2.xy = float2(vTexCoord0.x -vTexCoord0.z,vTexCoord0.y -vTexCoord0.w)
  95:     mov r0.w, c0.y
  96:     dp4 oPos.x, r0, c8
  97:     dp4 oPos.y, r0, c9
  98:     dp4 oPos.z, r0, c10
  99:     add r2.xy, -v2.zwzw, v2
 100:     dp4 oPos.w, r0, c11
 
	r1.xy = vCornerID.xy
 101:     mov r1.xy, v5
 
	oT0.xy = vCornerID.xy * float2(vTexCoord0.x -vTexCoord0.z,vTexCoord0.y -vTexCoord0.w) +float2(vTexCoord0.z,vTexCoord0.w)
	= float2(vCornerID.x * TexCoord0.x +vCornerID.x *(1-vTexCoord0.z),vCornerID.y * TexCoord0.y +vCornerID.y *(1-vTexCoord0.w))
	oT0.xy = o.texCoord0_1.xy = lerp( v.vTexCoord0.zw, v.vTexCoord0.xy, v.vCornerID.xy );
 102:     mad oT0.xy, r1, r2, v2.zwzw

	r0.xy = vCornerID.xy -0.5
	r1.w = ...
	oT0.zw = o.texCoord0_1.wz = lerp( v.vTexCoord1.zw, v.vTexCoord1.xy, v.vCornerID.xy );
	
////

Ok I'll stop here, that seems to be the standard shit bellow :D

////

 103:     add r0.zw, -v3.xywz, v3.xyyx
 104:     add r0.xy, v5, c4.z
 105:     lrp r1.w, v8.x, c55.y, c55.x
 
 106:     add r0.xy, r0, r0
 107:     mad oT0.zw, r1.xyyx, r0, v3.xywz
 
 108:     mul r1.xy, r1.w, r0
 109:     mad r1.xy, r1, c0.w, c0.w
 110:     mov r2.x, c1.w
 111:     add r0.w, r2.x, c55.x
 112:     add r2.xy, -v6.zwzw, v6
 113:     mad r0.w, v8.x, r0.w, c0.y
 114:     mad oT4.xy, r1, r2, v6.zwzw
 115:     mul r0.xy, r0, r0.w
 116:     mad r0.zw, r0.xyyx, c0.w, c0.w
 117:     add r1.zw, -v7.xywz, v7.xyyx
 118:     mad oT4.zw, r0, r1, v7.xywz

 // o.blendfactor0 = float4( v.vParms.x, 0, ?, 0 );
 // o.blendfactor0.z = v.vParms1.x;
 // o.fog = 1.0f;
 119:     mul oT1.xyw, v4.x, c0.yxzx
 120:     mov oT1.z, v8.x
 121:     mov oFog, c0.y

// approximately 122 instruction slots used

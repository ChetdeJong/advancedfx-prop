<html>
<head>
<title>AfxGoldSrc Xpress - advancedfx.org</title>
</head>
<body>

<p>
<code>
Target version: HLAE Xpress.<br />
Last revision: 2010-11-19T16:00Z.
</code>
</p>

<p>This is a very early release, meaning it will easily crash and have many flaws in the code or in the documentation (which from some point of view is code too and the other way round hehe).</p>

<h1>AfxGoldSrc Xpress</h1>

<p>
This documentation is supplied along with the download because HLAE Xpress is subject to heavy change and revision.
</p>

<p>
Xpress is meant for (future) wizard-driven auto code generation and experts.
If you have a problem with updates breaking your code, then please don't use it in the first place. This system is still
in development and we don't plan to hold-back changes just to keep old Xpress code from breaking.
</p>

<p>
Have fun!
</p>


<h2>Contents</h2>

<ul>
<li><a href="#std_syntax">Standard syntax</a></li>
<li><a href="#std_types">Standard types</a></li>
<li><a href="#std_functions">Standard functions</a></li>
<li><a href="#std_conventions">Standard conventions</a></li>
<li><a href="#note_evaluation">A note on evaluation</a></li>
<li><a href="#bubble_Root">Root bubble</a></li>
<li><a href="#bubble_Events">Events bubble</a></li>
<li><a href="#bubble_Info">Info bubble</a></li>
<li><a href="#bubble_Mod">Mod bubble</a></li>
</ul>


<h2><a name="std_syntax">Standard syntax</a></h2>

<code>
empty = ;<br />
arguments = empty | WS, WS*, function, arguments ;<br />
parenthesis = &quot;(&quot;, WS*, identifier, arguments, WS*, &quot;)&quot; ;<br />
function = parenthesis | identifier ;<br />
code = WS*, function, WS* ;<br />
</code>


<h2><a name="std_types">Standard types</a></h2>

<tt>
<a href="#std_type_Eof">Eof</a>, <a href="#std_type_Error">Error</a>,
<a href="#std_type_Null">Null</a>, <a href="#std_type_Void">Void</a>,
<a href="#std_type_Bool">Bool</a>, <a href="#std_type_Int">Int</a>,
<a href="#std_type_Float">Float</a>, <a href="#std_type_String">String</a>
</tt>

<a name="std_type_Eof"><h3>Eof</h3></a>

Internal.

<a name="std_type_Error"><h3>Error</h3></a>

Internal.

<a name="std_type_Null"><h3>Null</h3></a>

Most standard functions will skip arguments of this type at compile time. A Null function is not evaluated.

<a name="std_type_Void"><h3>Void</h3></a>

A evaluable function.

<a name="std_type_Bool"><h3>Bool</h3></a>

A evaluable function that retruns a boolean value.

<a name="std_type_Int"><h3>Int</h3></a>

A evaluable function that returns a integer value.

<a name="std_type_Float"><h3>Float</h3></a>

A evaluable function that returns a floating point value.

<a name="std_type_String"><h3>String</h3></a>

A evaluable function that returns a string value.



<h2><a name="std_functions">Standard functions</a></h2>

<dl>
<dt>boolValue -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>A boolean constant, one of &quot;<tt>false</tt>&quot; or &quot;<tt>true</tt>&quot;</dd>
<dt>integerValue -&gt; <a href="#std_type_Int">Int</a></dt><dd>A integer constant, i.e. &quot;<tt>0</tt>&quot;, &quot;<tt>-10</tt>&quot; or hexadecimal notation, i.e. &quot;<tt>0x1ACE</tt>&quot;</dd>
<dt>floatValue -&gt; <a href="#std_type_Float">Float</a></dt><dd>A floating point constant, i.e. &quot;<tt>0.0</tt>&quot;, &quot;<tt>-3.1416</tt>&quot;</dd>
<dt>&quot;<tt>null</tt>&quot; T* -&gt; <a href="#std_type_Null">Null</a>, where T is not <a href="#std_type_Error">Error</a></dt><dd>This function is a black hole and munches any number of arguments, preventing them from being evaluated.</dd>
<dt>&quot;<tt>void</tt>&quot; -&gt; <a href="#std_type_Void">Void</a></dt><dd>Can be used as a place holder, does pretty much nothing.</dd>
<dt>&quot;<tt>string</tt>&quot; -&gt; <a href="#std_type_String">String</a></dt><dd>A empty string.</dd>
<dt>&quot;<tt>string</tt>&quot; stringText -&gt; <a href="#std_type_String">String</a></dt><dd>A text string. Escapecharacter is back-slash (&quot;<tt>\</tt>&quot;). Thus a single-backslash would be &quot;<tt>\\</tt>&quot;, two backslashes would be &quot;<tt>\\\\</tt>&quot;. You need to escape round brackets only in case the don't form a valid parenthesis.<br /> Example: &quot;<tt>(string Hello World! (I am such a cool string) A escaped bracket lul: \), C:\\dir\\useful.avi.file)</tt>&quot;</dd>
<dt>&quot;<tt>s</tt>&quot; = &quot;<tt>string</tt>&quot;</dt>
<dt>&quot;<tt>and</tt>&quot; <a href="#std_type_Bool">Bool</a> <a href="#std_type_Bool">Bool</a>+ -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Logic function, short-circuit evaluation from left to right</dd>
<dt>&quot;<tt>&amp;&amp;</tt>&quot; = &quot;<tt>and</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>or</tt>&quot; <a href="#std_type_Bool">Bool</a> <a href="#std_type_Bool">Bool</a>+ -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Logic function, short-circuit evaluation from left to right</dd>
<dt>&quot;<tt>||</tt>&quot; = &quot;<tt>or</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>not</tt>&quot; <a href="#std_type_Bool">Bool</a> -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Logic function.</dd>
<dt>&quot;<tt>!</tt>&quot; = &quot;<tt>not</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>less</tt>&quot; T T -&gt; <a href="#std_type_Bool">Bool</a>, where T = <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd>Comparison function.</dd>
<dt>&quot;<tt>&lt;</tt>&quot; = &quot;<tt>less</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>lessOrEqual</tt>&quot; T T -&gt; <a href="#std_type_Bool">Bool</a>, where T = <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd>Comparison function.</dd>
<dt>&quot;<tt>&lt;</tt>=&quot; = &quot;<tt>lessOrEqual</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>equal</tt>&quot; T T -&gt; <a href="#std_type_Bool">Bool</a>, where T = <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd>Comparison function.</dd>
<dt>&quot;<tt>==</tt>&quot; = &quot;<tt>equal</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>greater</tt>&quot; T T -&gt; <a href="#std_type_Bool">Bool</a>, where T = <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd>Comparison function.</dd>
<dt>&quot;<tt>&gt;</tt>&quot; = &quot;<tt>greater</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>greaterOrEqual</tt>&quot; T T -&gt; <a href="#std_type_Bool">Bool</a>, where T = <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd>Comparison function.</dd>
<dt>&quot;<tt>&gt;=</tt>&quot; = &quot;<tt>greaterOrEqual</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>in</tt>&quot; T T* -&gt; <a href="#std_type_Bool">Bool</a>, where T = <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a></dt><dd>Logic function, short-circuit evaluation from left to right</dd>
<dt>&quot;<tt>max</tt>&quot; <a href="#std_type_Bool">Bool</a>+ -&gt; <a href="#std_type_Bool">Bool</a></dt><dd></dd>
<dt>&quot;<tt>max</tt>&quot; <a href="#std_type_Int">Int</a>+ -&gt; <a href="#std_type_Int">Int</a></dt><dd></dd>
<dt>&quot;<tt>min</tt>&quot; <a href="#std_type_Bool">Bool</a>+ -&gt; <a href="#std_type_Bool">Bool</a></dt><dd></dd>
<dt>&quot;<tt>min</tt>&quot; <a href="#std_type_Int">Int</a>+ -&gt; <a href="#std_type_Int">Int</a></dt><dd></dd>
<dt>&quot;<tt>if</tt>&quot; <a href="#std_type_Bool">Bool</a> T T -&gt; T, where T = <a href="#std_type_Void">Void</a> | <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd></dd>
<dt>&quot;<tt>?</tt>&quot; = &quot;<tt>if</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt><a name="std_function_do">do</a></tt>&quot; (<a href="#std_type_Void">Void</a> | <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a>)* T -&gt; T, where T = <a href="#std_type_Void">Void</a> | <a href="#std_type_Bool">Bool</a> | <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd>Evaluates all arguments from left to right and returns the result of the last argument</dd>
<dt>&quot;<tt>.</tt>&quot; = &quot;<tt>do</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>sum</tt>&quot; T+ -&gt; T, where T = <a href="#std_type_Int">Int</a> | <a href="#std_type_Float">Float</a></dt><dd></dd>
<dt>&quot;<tt>+</tt>&quot; = &quot;<tt>sum</tt>&quot;</dt><dd></dd>
<dt>&quot;<tt>stringFromFile</tt>&quot; <a href="#std_type_String">String</a> -&gt; <a href="#std_type_String">String</a></dt><dd>Loads a string from a (text) file. Example: &quot;<tt>(stringFromFile (s C:\\some.txt))</tt>&quot;</dd>
<dt>&quot;<tt>ceval</tt>&quot; <a href="#std_type_String">String</a> -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Compiles a <a href="#std_type_Void">Void</a> function from a given string and upon success evaluates it and returns true (otherwise returns false). Example: &quot;<tt>(ceval (stringFromFile (s C:\\code.x.txt)))</tt>&quot;</dd>
</dl>


<h2><a name="std_conventions">Standard conventions</a></h2>

<h3><a name="std_convention_event">Event</a></h3>

<p>
A event is a very lazy function. It stores it's argument function of type T and calls it upon s.th. happening (potentially be multiple times or sometimes never).
</p>

<p><code>
EventName T -> Void - Set event argument.<br />
EventName -> T - Call event.<br />
</code></p>

<h3><a name="std_convention_link">Link</a></h3>

A link is a <a href="#std_function_do">do</a> function that executes in a different bubble (environment).<br />
We use this technique to structure our evironment into inter-linked bubbles.



<h2><a name="note_evaluation">A note on evaluation</a></h2>

<p>
As a golden rule don't make assumptions about evaluation, that is about if, when and how often your function (argument) is evaluated, unless the
documentation clearly states what will happen.
</p>

<p>
If you want to make sure your function arguments are executed in a specific order, have a look at some of the standard functions, i.e. the <a href="#std_function_do">do</a> function!
</p>

<h2><a name="bubble_Root">Root bubble</a></h2>

This is the core bubble accessed throughout the xpress console command.

<h3>Functions</h3>

<dl>
<dt></dt><dd><a href="#std_functions">Standard functions</a></dd>
<dt>&quot;./&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;..&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;.events&quot;</dt><dd><a href="#bubble_Events">Events bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;.info&quot;</dt><dd><a href="#bubble_Info">Info bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;.mod&quot;</dt><dd><a href="#bubble_Mod">Mod bubble</a> <a href="#std_convention_link">link</a></dd>
</dl>


<h2><a name="bubble_Events">Events bubble</a></h2>

This is the bubble that allows you to handle various events.

<h3>Functions</h3>

<code>
<dl>
<dt></dt><dd><a href="#std_functions">Standard functions</a></dd>
<dt>&quot;<tt>./</tt>&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;<tt>..</tt>&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;<tt>GlBegin</tt>&quot;</dt><dd><a href="#std_type_Void">Void</a> <a href="#std_convention_event">event</a>.<br />Called right before the next object (OpenGL primitive) is drawn. This is a good event to decide / drive your object <a href="#bubble_Mod">modifiers</a>.</dd>
<dt>&quot;<tt>GlEnd</tt>&quot;</dt><dd><a href="#std_type_Void">Void</a> <a href="#std_convention_event">event</a>.<br />Called right after an object (OpenGL primitive) has been drawn.</dd>
<dt>&quot;<tt>FilmingStart</tt>&quot;</dt><dd><a href="#std_type_Void">Void</a> <a href="#std_convention_event">event</a>.<br />Called upon mirv_recordmovie_start.</dd>
<dt>&quot;<tt>FilmingStop</tt>&quot;</dt><dd><a href="#std_type_Void">Void</a> <a href="#std_convention_event">event</a>.<br />Called upon mirv_recordmovie_stop.</dd>
<dt>&quot;<tt><a name="bubble_Events_Matte">Matte</a></tt>&quot;</dt><dd><a href="#std_type_Int">Int</a> <a href="#std_convention_event">event</a>.<br />This allows to control AfxGoldSrc's matte operation. Return -1 to let HLAE decide (normal operation), 0 to draw, 1 to mask or 2 to hide the next object drawn.</dd>
<dt>&quot;<tt>RenderViewBegin</tt>&quot;</dt><dd><a href="#std_type_Int">Bool</a> <a href="#std_convention_event">event</a>.<br />This allows you to control wether the view will be rendered (true) or not (false, in this case RenderViewEnd won't be called).</dd>
<dt>&quot;<tt>RenderViewEnd</tt>&quot;</dt><dd><a href="#std_type_Int">Bool</a> <a href="#std_convention_event">event</a>.<br />This event allows you to control wether antoher view is rendered (true) or not (false). If you don't pay attention here athen you'll lock-up your game in a endless loop or even crash it.</dd>
</dl>
</code>


<h2><a name="bubble_Info">Info bubble</a></h2>

This bubble supplies information which can be very useful to drive your <a href="#bubble_Events_Matte">matte</a> or your <a href="#bubble_Mod">modifiers</a>.

<h3>Functions</h3>

<dl>
<dt></dt><dd><a href="#std_functions">Standard functions</a></dd>
<dt>&quot;<tt>./</tt>&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;<tt>..</tt>&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;<tt>CurrentGlMode</tt>&quot; -&gt; <a href="#std_type_Int">Int</a></dt><dd>Returns integer value of current OpenGL mode (upon glBegin).</dd>
<dt>&quot;<tt>CurrentStreamIndex</tt>&quot; -&gt; <a href="#std_type_Int">Int</a></dt><dd>Returns index of current stream (-1 for unknown, 0 first stream (i.e. world), 1 second stream (i.e. entity stream).</dd>
<dt>&quot;<tt>GetCurrentEntityIndex</tt>&quot; -&gt; <a href="#std_type_Int">Int</a></dt><dd>Returns index of current Half-Life enity being drawn.</dd>
<dt>&quot;<tt>GetIsPlayer</tt>&quot; <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Returns if the index passed is a player entity (true) or not (false).</dd>
<dt>&quot;<tt>IsFilming</tt>&quot; -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Returns if the user is filming s.th. (mirv_recordmovie_start).</dd>
<dt>&quot;<tt>InRDrawEntitiesOnList</tt>&quot; -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Returns if drawing (usual) entities right now.</dd>
<dt>&quot;<tt>InRDrawParticles</tt>&quot; -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Returns if drawing particles (sparks, blood, ...) right now.</dd>
<dt>&quot;<tt>InRDrawViewModel</tt>&quot; -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Returns if drawing the in-eye weapon model right now.</dd>
<dt>&quot;<tt>InRRenderView</tt>&quot; -&gt; <a href="#std_type_Bool">Bool</a></dt><dd>Returns if drawing the view right now.</dd>
</dl>


<h2><a name="bubble_Mod">Mod bubble</a></h2>

This bubble switch-able paremetrized object (OpenGL primitive) modifier stacks, which are great for implementing special effects
in combination with the <a href="#bubble_Info">Info bubble</a>.


<h3>Functions</h3>

<dl>
<dt></dt><dd><a href="#std_functions">Standard functions</a></dd>
<dt>&quot;<tt>./</tt>&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>
<dt>&quot;<tt>..</tt>&quot;</dt><dd><a href="#bubble_Root">Root bubble</a> <a href="#std_convention_link">link</a></dd>

<dt>&quot;<tt>Add</tt>&quot; -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Adds a new modifier stack (it's index will be the current count of stacks).</dd>

<dt>&quot;<tt>AddColor</tt>&quot; <a href="#std_type_Int">Int</a> <a href="#std_type_Float">Float</a> <a href="#std_type_Float">Float</a> <a href="#std_type_Float">Float</a> <a href="#std_type_Float">Float</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Parameters are (index, red, green, blue, alpha). Adds a Color modfier to the stack with the given index.
The color parameters should be between 0.0 to 1.0.
The parameters red, green, blue and alpha are evaluated each time the modifier is applied.
</dd>

<dt>&quot;<tt>AddColorMask</tt>&quot; <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Parameters are (index, modeRed, modeGreen, modeBlue, modeAlpha). Adds a ColorMask modfier to the stack with the given index.
The mask specifies wether a color channel is drawn (1), or not (-1), or if the current mode remains unchanged (0).
The parameters modeRed, modeGreen, modeBlue and modeAlpha are evaluated each time the modifier is applied.
</dd>

<dt>&quot;<tt>AddDepthMask</tt>&quot; <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Parameters are (index, modeDepth). Adds a DepthMask modfier to the stack with the given index.
The mask specifies wether the depth buffer is drawn (1), or not (-1), or if the current mode remains unchanged (0).
The parameter modeDepth is evaluated each time the modifier is applied.
</dd>

<dt>&quot;<tt>AddMask</tt>&quot; <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Parameters are (index, mode). Adds a Mask modfier to the stack with the given index.
The mask specifies wether the color and depth buffers are drawn (1), or not (-1), or the current mode remains unchanged (0).
The parameter mode is evaluated each time the modifier is applied.
</dd>

<dt>&quot;<tt>AddReplace</tt>&quot; <a href="#std_type_Int">Int</a> <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Parameters are (index, red, green, blue). Adds a Replace modfier to the stack with the given index.
The color parameters specify the color of the texture (0 - 255) to be used for replacing.
The parameters red, green and blue are evaluated when the modifier is added to the stack (that is because the texture has to be
newely generated). Use this modifier rareley.
</dd>

<dt>&quot;<tt>Active</tt>&quot; -&gt; <a href="#std_type_Int">Int</a></dt>
<dd>Retruns the index of the modifier stack currently active, or an invalid index if none is active.</dd>

<dt>&quot;<tt>Active</tt>&quot; <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Set the active modifier stack (or in case you don't want any to be active, set -1).</dd>

<dt>&quot;<tt>Clear</tt>&quot; -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Remove all modifier stacks.</dd>

<dt>&quot;<tt>Count</tt>&quot; -&gt; <a href="#std_type_Int">Int</a></dt>
<dd>Get the number of available modifier stacks (their indexes are 0 to Count-1 then).</dd>


<dt>&quot;<tt>Remove</tt>&quot; <a href="#std_type_Int">Int</a> -&gt; <a href="#std_type_Void">Void</a></dt>
<dd>Remove modifier stack with the given index.</dd>


</dl>


</body>
</html>